<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>National Council Seat Allocator with Factions</title>
<style>
body { font-family: Arial, sans-serif; margin: 20px; background: #f7f9fc; color: #222; }
h1,h2,h3 { margin: 10px 0; }
table { width: 100%; border-collapse: collapse; margin-top: 6px; }
th, td { padding: 6px 8px; border: 1px solid #e6e9ef; font-size: 13px; }
input[type="text"], input[type="number"] { width: 100%; padding: 6px; box-sizing: border-box; }
input[type="color"] { width: 48px; height: 32px; border: none; cursor: pointer; }
button { padding: 6px 10px; border-radius: 6px; border: 1px solid #cfcfcf; background: #f0f0f0; cursor: pointer; }
button.primary { background: #2d6cdf; color: #fff; border-color: #2a63d6; }
button.secondary { background: #6c757d; color: #fff; border-color: #5a6268; }
.controls { display: flex; gap: 10px; flex-wrap: wrap; margin-top: 8px; align-items: center; }
pre#results { max-height: 300px; overflow: auto; background: #fcfcff; padding: 10px; border-radius: 6px; border: 1px solid #e7e9ef; font-size: 13px; white-space: pre-wrap; }
canvas { border:1px solid #ccc; margin-top:10px; border-radius:6px; background: transparent; }
.faction-section { margin-left: 20px; margin-bottom: 15px; border-left: 3px solid #e9ecef; padding-left: 15px; }
.party-header { display: flex; align-items: center; gap: 10px; margin: 10px 0; }
.party-total { font-weight: bold; margin: 5px 0; }
</style>
</head>
<body>

<h1>National Council Seat Allocator</h1>

<h2>Parties and Factions</h2>
<div id="partiesContainer">
  <!-- Party template -->
  <div class="party-container" data-party-index="0">
    <div class="party-header">
      <input type="text" class="party-name" value="Reclaim" placeholder="Party Name">
      <input type="color" class="party-color" value="#00ffff">
      <button onclick="addFaction(this)" class="secondary">+ Add Faction</button>
      <button onclick="deleteParty(this)" class="delete">Delete Party</button>
    </div>
    <div class="party-total">Total Votes: <span class="party-votes">0</span></div>
    <div class="faction-section">
      <table class="faction-table">
        <thead><tr><th>Faction Name</th><th>Votes</th><th>Action</th></tr></thead>
        <tbody>
          <tr><td><input type="text" class="faction-name" value="Main Faction"></td><td><input type="number" class="faction-votes" value="6" min="0" onchange="updatePartyTotal(this)"></td><td><button onclick="deleteRow(this)">Delete</button></td></tr>
        </tbody>
      </table>
    </div>
  </div>
  
  <!-- More parties will be added here -->
  <div class="party-container" data-party-index="1">
    <div class="party-header">
      <input type="text" class="party-name" value="Purple Crown" placeholder="Party Name">
      <input type="color" class="party-color" value="#800080">
      <button onclick="addFaction(this)" class="secondary">+ Add Faction</button>
      <button onclick="deleteParty(this)" class="delete">Delete Party</button>
    </div>
    <div class="party-total">Total Votes: <span class="party-votes">0</span></div>
    <div class="faction-section">
      <table class="faction-table">
        <thead><tr><th>Faction Name</th><th>Votes</th><th>Action</th></tr></thead>
        <tbody>
          <tr><td><input type="text" class="faction-name" value="Main Faction"></td><td><input type="number" class="faction-votes" value="5" min="0" onchange="updatePartyTotal(this)"></td><td><button onclick="deleteRow(this)">Delete</button></td></tr>
        </tbody>
      </table>
    </div>
  </div>
  <div class="party-container" data-party-index="2">
    <div class="party-header">
      <input type="text" class="party-name" value="Social Democratic" placeholder="Party Name">
      <input type="color" class="party-color" value="#ff0000">
      <button onclick="addFaction(this)" class="secondary">+ Add Faction</button>
      <button onclick="deleteParty(this)" class="delete">Delete Party</button>
    </div>
    <div class="party-total">Total Votes: <span class="party-votes">0</span></div>
    <div class="faction-section">
      <table class="faction-table">
        <thead><tr><th>Faction Name</th><th>Votes</th><th>Action</th></tr></thead>
        <tbody>
          <tr><td><input type="text" class="faction-name" value="Main Faction"></td><td><input type="number" class="faction-votes" value="4" min="0" onchange="updatePartyTotal(this)"></td><td><button onclick="deleteRow(this)">Delete</button></td></tr>
        </tbody>
      </table>
    </div>
  </div>
  <div class="party-container" data-party-index="3">
    <div class="party-header">
      <input type="text" class="party-name" value="Solarist" placeholder="Party Name">
      <input type="color" class="party-color" value="#ffff00">
      <button onclick="addFaction(this)" class="secondary">+ Add Faction</button>
      <button onclick="deleteParty(this)" class="delete">Delete Party</button>
    </div>
    <div class="party-total">Total Votes: <span class="party-votes">0</span></div>
    <div class="faction-section">
      <table class="faction-table">
        <thead><tr><th>Faction Name</th><th>Votes</th><th>Action</th></tr></thead>
        <tbody>
          <tr><td><input type="text" class="faction-name" value="Main Faction"></td><td><input type="number" class="faction-votes" value="3" min="0" onchange="updatePartyTotal(this)"></td><td><button onclick="deleteRow(this)">Delete</button></td></tr>
        </tbody>
      </table>
    </div>
  </div>
  <div class="party-container" data-party-index="4">
    <div class="party-header">
      <input type="text" class="party-name" value="Progressive" placeholder="Party Name">
      <input type="color" class="party-color" value="#ff69b4">
      <button onclick="addFaction(this)" class="secondary">+ Add Faction</button>
      <button onclick="deleteParty(this)" class="delete">Delete Party</button>
    </div>
    <div class="party-total">Total Votes: <span class="party-votes">0</span></div>
    <div class="faction-section">
      <table class="faction-table">
        <thead><tr><th>Faction Name</th><th>Votes</th><th>Action</th></tr></thead>
        <tbody>
          <tr><td><input type="text" class="faction-name" value="Main Faction"></td><td><input type="number" class="faction-votes" value="2" min="0" onchange="updatePartyTotal(this)"></td><td><button onclick="deleteRow(this)">Delete</button></td></tr>
        </tbody>
      </table>
    </div>
  </div>
</div>
<button onclick="addParty()" class="primary">+ Add Party</button>

<h2>Party Candidates</h2>
<div id="candidatesContainer">
  <div class="candidate-list" data-party-index="0">
    <h3>Reclaim</h3>
    <input type="text" class="candidate-names" value="Josef, Bela Andrassy, Janek Komiga, John Louis Mormon, Robert Fico">
  </div>
  <div class="candidate-list" data-party-index="1">
    <h3>Purple Crown</h3>
    <input type="text" class="candidate-names" value="Cierna, Oldrich Vladislav, Schwarz, Katereinna Eliska Piotrowski">
  </div>
  <div class="candidate-list" data-party-index="2">
    <h3>Social Democratic</h3>
    <input type="text" class="candidate-names" value="Dubovy Sedliak, Jakub Mazar, Filip Kozákhvi- ezdoslaviç, Staunch, Sigmaiusasin">
  </div>
  <div class="candidate-list" data-party-index="3">
    <h3>Solarist</h3>
    <input type="text" class="candidate-names" value="Hiro Solarist, Circa">
  </div>
  <div class="candidate-list" data-party-index="4">
    <h3>Progressive</h3>
    <input type="text" class="candidate-names" value="Michael Brain">
  </div>
</div>
<button onclick="addCandidateList()" class="primary">+ Add Candidate List</button>

<h2>Settings</h2>
<label>Required Vacant Seats: <input type="number" id="requiredVacant" value="5" min="0"></label><br>
<label>Maximum Total Seats: <input type="number" id="maxSeats" value="150" min="1"></label><br>
<label>Threshold (% votes required): <input type="number" id="threshold" value="5" min="0" max="100"></label><br>

<div class="controls">
  <button class="primary" onclick="allocateSeats()">Allocate Seats</button>
  <button onclick="exportCSV()">Export CSV</button>
  <button onclick="downloadSeatImage()">Download Seat Grid Image</button>
  <button onclick="downloadSortedSeatImage()">Download Sorted Seat Grid Image</button>
</div>

<h2>Results</h2>
<pre id="results">Run allocation to see results here.</pre>

<h2>Original Seat Grid</h2>
<canvas id="seatCanvas"></canvas>

<h2>Sorted Seat Grid (Largest Party → Smallest, Vacants Last)</h2>
<canvas id="seatCanvasSorted"></canvas>

<script>
// --- Party and Faction Management ---
let partyCounter = 5; // Start after the initial 5 parties

// Add a new party
function addParty() {
    const partyIndex = partyCounter++;
    const partyDiv = document.createElement('div');
    partyDiv.className = 'party-container';
    partyDiv.dataset.partyIndex = partyIndex;
    
    // Generate a random color
    const randomColor = '#' + Math.floor(Math.random()*16777215).toString(16);
    const initialFactionId = 'faction-' + Date.now();
    
    partyDiv.innerHTML = `
        <div class="party-header">
            <input type="text" class="party-name" placeholder="Party Name">
            <input type="color" class="party-color" value="${randomColor}">
            <button onclick="addFaction(this)" class="secondary">+ Add Faction</button>
            <button onclick="deleteParty(this)" class="delete">Delete Party</button>
        </div>
        <div class="party-total">Total Votes: <span class="party-votes">0</span></div>
        <div class="faction-section">
            <table class="faction-table">
                <thead><tr><th>Faction Name</th><th>Votes</th><th>Actions</th></tr></thead>
                <tbody>
                    <tr data-faction-id="${initialFactionId}">
                        <td><input type="text" class="faction-name" value="Main Faction" onchange="updateFactionName('${initialFactionId}', this.value)"></td>
                        <td><input type="number" class="faction-votes" value="0" min="0" onchange="updatePartyTotal(this)"></td>
                        <td>
                            <button onclick="showFactionCandidates('${initialFactionId}')">Edit Candidates</button>
                            <button onclick="deleteFaction(this)">Delete</button>
                        </td>
                    </tr>
                </tbody>
            </table>
        </div>
    `;
    
    document.getElementById('partiesContainer').appendChild(partyDiv);
    
    // Add corresponding candidate lists
    addCandidateList(partyIndex);
    addFactionCandidateList(partyIndex, initialFactionId);
}

// Add a new faction to a party
function addFaction(button) {
    const partyContainer = button.closest('.party-container');
    const partyIndex = partyContainer.dataset.partyIndex;
    const tbody = partyContainer.querySelector('.faction-table tbody');
    const factionId = 'faction-' + Date.now(); // Unique ID for the faction
    
    const newRow = document.createElement('tr');
    newRow.dataset.factionId = factionId;
    newRow.innerHTML = `
        <td>
            <input type="text" class="faction-name" value="New Faction" 
                   onchange="updateFactionName('${factionId}', this.value)">
        </td>
        <td><input type="number" class="faction-votes" value="0" min="0" onchange="updatePartyTotal(this)"></td>
        <td>
            <button onclick="showFactionCandidates('${factionId}')">Edit Candidates</button>
            <button onclick="deleteFaction(this)">Delete</button>
        </td>
    `;
    
    tbody.appendChild(newRow);
    updatePartyTotal(button);
    
    // Add a new candidate list for this faction
    addFactionCandidateList(partyIndex, factionId);
    
    return factionId;
}

// Update faction name in the corresponding candidate list
function updateFactionName(factionId, newName) {
    const candidateHeader = document.querySelector(`.faction-candidates[data-faction-id="${factionId}"] h4`);
    if (candidateHeader) {
        candidateHeader.textContent = newName || 'Unnamed Faction';
    }
}

// Show/hide faction candidates
function showFactionCandidates(factionId) {
    const candidateDiv = document.querySelector(`.faction-candidates[data-faction-id="${factionId}"]`);
    if (candidateDiv) {
        candidateDiv.style.display = candidateDiv.style.display === 'none' ? 'block' : 'none';
    }
}

// Delete a faction and its candidate list
function deleteFaction(button) {
    const row = button.closest('tr');
    if (row && confirm('Are you sure you want to delete this faction and its candidates?')) {
        const factionId = row.dataset.factionId;
        
        // Remove the faction row
        row.remove();
        
        // Remove the faction's candidate list
        const candidateDiv = document.querySelector(`.faction-candidates[data-faction-id="${factionId}"]`);
        if (candidateDiv) {
            candidateDiv.remove();
        }
        
        // Update party total
        updatePartyTotal(button);
    }
}

// Add a candidate list for a faction
function addFactionCandidateList(partyIndex, factionId) {
    const factionsContainer = document.getElementById('factionsCandidatesContainer') || (() => {
        // Create the container if it doesn't exist
        const container = document.createElement('div');
        container.id = 'factionsCandidatesContainer';
        container.style.marginTop = '20px';
        document.querySelector('body').appendChild(container);
        return container;
    })();
    
    const factionCandidatesDiv = document.createElement('div');
    factionCandidatesDiv.className = 'faction-candidates';
    factionCandidatesDiv.dataset.factionId = factionId;
    factionCandidatesDiv.style.display = 'none';
    factionCandidatesDiv.style.marginLeft = '30px';
    factionCandidatesDiv.style.marginBottom = '15px';
    factionCandidatesDiv.style.padding = '10px';
    factionCandidatesDiv.style.borderLeft = '2px solid #ccc';
    
    factionCandidatesDiv.innerHTML = `
        <h4>New Faction</h4>
        <input type="text" class="faction-candidate-names" 
               placeholder="Candidate 1, Candidate 2, ..." 
               data-faction-id="${factionId}">
    `;
    
    factionsContainer.appendChild(factionCandidatesDiv);
    return factionCandidatesDiv;
}

// Delete a party
function deleteParty(button) {
    if (confirm('Are you sure you want to delete this party and all its factions?')) {
        const partyContainer = button.closest('.party-container');
        const partyIndex = partyContainer.dataset.partyIndex;
        
        // Remove the party container
        partyContainer.remove();
        
        // Remove the corresponding candidate list
        const candidateList = document.querySelector(`.candidate-list[data-party-index="${partyIndex}"]`);
        if (candidateList) {
            candidateList.remove();
        }
    }
}

// Update the party's total votes
function updatePartyTotal(input) {
    const partyContainer = input.closest('.party-container');
    const factionInputs = partyContainer.querySelectorAll('.faction-votes');
    let total = 0;
    
    factionInputs.forEach(input => {
        total += parseInt(input.value) || 0;
    });
    
    const totalSpan = partyContainer.querySelector('.party-votes');
    if (totalSpan) {
        totalSpan.textContent = total;
    }
}

// Add a new candidate list
function addCandidateList(partyIndex = null) {
    const candidatesContainer = document.getElementById('candidatesContainer');
    const newCandidateDiv = document.createElement('div');
    
    if (partyIndex === null) {
        // If no party index provided, this is a new party
        partyIndex = partyCounter - 1; // Use the most recent party index
    }
    
    newCandidateDiv.className = 'candidate-list';
    newCandidateDiv.dataset.partyIndex = partyIndex;
    newCandidateDiv.innerHTML = `
        <h3>Party Name</h3>
        <input type="text" class="candidate-names" placeholder="Candidate 1, Candidate 2, ...">
    `;
    
    candidatesContainer.appendChild(newCandidateDiv);
    
    // Link the party name to the candidate list
    const partyNameInput = document.querySelector(`.party-container[data-party-index="${partyIndex}"] .party-name`);
    if (partyNameInput) {
        // Update the candidate list title when party name changes
        partyNameInput.addEventListener('input', function() {
            const candidateHeader = newCandidateDiv.querySelector('h3');
            if (candidateHeader) {
                candidateHeader.textContent = this.value || 'Unnamed Party';
            }
        });
    }
    
    return newCandidateDiv;
}

// --- Global data ---
let seatAssignmentsGlobal=[], councilSeatsGlobal={}, partyColorsGlobal={}, councilPartiesGlobal=[], occupiedByPartyGlobal={}, vacantByPartyGlobal={}, nextPartyGlobal='';

// --- Allocation ---
function allocateSeats() {
    const partyData = {};
    const partyColors = {};
    const partyOrder = [];
    const partyCandidates = {};
    let totalVotes = 0;
    const showFactions = document.getElementById('showFactions').checked;
    
    // Collect party and faction data
    document.querySelectorAll('.party-container').forEach(partyContainer => {
        const partyName = partyContainer.querySelector('.party-name').value.trim();
        const partyColor = partyContainer.querySelector('.party-color').value || '#888888';
        
        if (!partyName) return; // Skip parties with no name
        
        // Get all factions for this party
        const factions = [];
        let partyVotes = 0;
        
        partyContainer.querySelectorAll('.faction-table tbody tr').forEach(row => {
            const nameInput = row.querySelector('.faction-name');
            const votesInput = row.querySelector('.faction-votes');
            
            if (nameInput && votesInput) {
                const factionName = nameInput.value.trim() || 'Unnamed Faction';
                const factionVotes = parseInt(votesInput.value) || 0;
                
                if (factionName) {
                    factions.push({
                        name: factionName,
                        votes: factionVotes
                    });
                    partyVotes += factionVotes;
                }
            }
        });
        
        // Get candidates for this party
        const partyIndex = partyContainer.dataset.partyIndex;
        const candidateList = document.querySelector(`.candidate-list[data-party-index="${partyIndex}"]`);
        const candidates = candidateList ? 
            candidateList.querySelector('.candidate-names').value
                .split(',')
                .map(s => s.trim())
                .filter(Boolean) : [];
        
        // Store party data
        partyData[partyName] = {
            votes: partyVotes,
            factions: factions,
            color: partyColor,
            candidates: candidates
        };
        
        partyColors[partyName] = partyColor;
        partyOrder.push(partyName);
        totalVotes += partyVotes;
    });
    
    // Get allocation parameters
    const threshold = parseFloat(document.getElementById('threshold').value) || 0;
    const requiredVacantSeats = parseInt(document.getElementById('requiredVacant').value) || 0;
    const maxSeats = parseInt(document.getElementById('maxSeats').value) || 1000;
    
    // Calculate which parties meet the threshold
    const councilParties = [];
    const councilSeats = {};
    const occupiedByParty = {};
    const vacantByParty = {};
    
    for (const party of partyOrder) {
        const partyVotes = partyData[party].votes;
        if (totalVotes > 0 && (partyVotes / totalVotes * 100) < threshold) continue;
        
        councilParties.push(party);
        councilSeats[party] = 0;
        occupiedByParty[party] = 0;
        vacantByParty[party] = 0;
    }
    
    if (councilParties.length === 0) {
        document.getElementById('results').textContent = 'No parties meet the threshold.';
        drawSeatGrid([], 0, 'seatCanvas');
        drawSeatGrid([], 0, 'seatCanvasSorted');
        return;
    }
    
    // Allocate seats to parties
    const seatAssignments = [];
    let assignedSeats = 0;
    let vacantSeats = 0;
    let occupiedSeats = 0;
    
    // Function to get the next candidate for a party
    function getNextCandidate(party) {
        const candidates = [...(partyData[party].candidates || [])];
        return candidates.length > 0 ? candidates.shift() : null;
    }
    
    // Allocate seats to parties
    while (vacantSeats < requiredVacantSeats && assignedSeats < maxSeats) {
        let maxQ = -1;
        let nextParty = councilParties[0];
        
        // Find the party with the highest quotient
        for (const party of councilParties) {
            const q = (partyData[party].votes || 0) / (councilSeats[party] + 1);
            if (q > maxQ) {
                maxQ = q;
                nextParty = party;
            }
        }
        
        // Assign the seat
        const candidate = getNextCandidate(nextParty);
        assignedSeats++;
        councilSeats[nextParty]++;
        
        if (candidate) {
            seatAssignments.push([assignedSeats, nextParty, candidate]);
            occupiedSeats++;
            occupiedByParty[nextParty]++;
        } else {
            seatAssignments.push([assignedSeats, nextParty, 'VACANT']);
            vacantSeats++;
            vacantByParty[nextParty]++;
        }
    }
    
    // Calculate next party in line
    let nextInLine = 'N/A';
    if (assignedSeats < maxSeats) {
        let maxQ = -1;
        for (const party of councilParties) {
            const q = (partyData[party].votes || 0) / (councilSeats[party] + 1);
            if (q > maxQ) {
                maxQ = q;
                nextInLine = party;
            }
        }
    }
    
    // Allocate seats to factions within each party if enabled
    const factionSeatAssignments = [];
    if (showFactions) {
        for (const party of councilParties) {
            const partySeats = councilSeats[party];
            if (partySeats === 0) continue;
            
            const partyInfo = partyData[party];
            const factions = partyInfo.factions || [];
            
            if (factions.length === 0) continue;
            
            // Calculate total votes for all factions in this party
            const totalFactionVotes = factions.reduce((sum, f) => sum + (f.votes || 0), 0);
            if (totalFactionVotes === 0) continue;
            
            // Allocate seats to factions using the same method as for parties
            const factionSeats = {};
            const factionCandidates = {};
            
            // Initialize faction data
            for (const faction of factions) {
                factionSeats[faction.name] = 0;
                
                // Get candidates for this faction from the UI
                const factionCandidateInput = document.querySelector(`.faction-candidate-names[data-faction-id^="${faction.name}"], 
                                                                 .faction-candidate-names[data-faction-id$="${faction.name}"]`);
                
                if (factionCandidateInput) {
                    // Use the faction's specific candidates if available
                    factionCandidates[faction.name] = factionCandidateInput.value
                        .split(',')
                        .map(s => s.trim())
                        .filter(Boolean);
                } else {
                    // Fall back to party candidates if no faction-specific candidates exist
                    factionCandidates[faction.name] = [...(partyInfo.candidates || [])];
                }
            }
            
            // Allocate seats to factions
            const factionSeatAssignments = [];
            
            for (let i = 0; i < partySeats; i++) {
                let maxFactionQ = -1;
                let nextFaction = null;
                
                // Find the faction with the highest quotient
                for (const faction of factions) {
                    const q = (faction.votes || 0) / ((factionSeats[faction.name] || 0) + 1);
                    if (q > maxFactionQ) {
                        maxFactionQ = q;
                        nextFaction = faction;
                    }
                }
                
                if (nextFaction) {
                    const factionName = nextFaction.name;
                    factionSeats[factionName] = (factionSeats[factionName] || 0) + 1;
                    
                    // Get the next candidate from this faction's list
                    const candidates = factionCandidates[factionName] || [];
                    const candidate = candidates.length > 0 ? candidates.shift() : `Faction Member ${factionSeats[factionName]}`;
                    
                    factionSeatAssignments.push({
                        party: party,
                        faction: factionName,
                        candidate: candidate,
                        seatNumber: i + 1
                    });
                }
            }
            
            // Add detailed faction seat assignments to the output
            if (factionSeatAssignments.length > 0) {
                output += `\n${party} Faction Seat Assignments:\n`;
                factionSeatAssignments.forEach(({faction, candidate, seatNumber}) => {
                    output += `  Seat ${seatNumber}: ${faction} → ${candidate}\n`;
                });
            }
        }
    }
    
    // Update global state
    seatAssignmentsGlobal = seatAssignments;
    councilSeatsGlobal = councilSeats;
    partyColorsGlobal = partyColors;
    councilPartiesGlobal = councilParties;
    occupiedByPartyGlobal = occupiedByParty;
    vacantByPartyGlobal = vacantByParty;
    nextPartyGlobal = nextInLine;
    
    // Generate output
    let output = 'National Council Seat Assignments:\n';
    
    // Add seat assignments
    seatAssignments.forEach(([num, party, member]) => {
        output += `Seat ${num}: ${party} → ${member}\n`;
    });
    
    // Add party seat totals
    output += '\nSeat Totals (including vacant seats):\n';
    for (const party of councilParties) {
        output += `${party}: ${councilSeats[party]}\n`;
    }
    
    // Add faction seat distribution if enabled
    if (showFactions && factionSeatAssignments.length > 0) {
        output += '\nFaction Seat Distribution:\n';
        for (const { party, faction, seats } of factionSeatAssignments) {
            output += `${party} - ${faction}: ${seats} seat${seats !== 1 ? 's' : ''}\n`;
        }
    }
    
    // Add occupied and vacant seats
    output += '\nOccupied Seats by Party:\n';
    for (const party of councilParties) {
        output += `${party}: ${occupiedByParty[party]}\n`;
    }
    
    output += '\nVacant Seats by Party:\n';
    for (const party of councilParties) {
        output += `${party}: ${vacantByParty[party]}\n`;
    }
    
    output += `\nTotal Seats Assigned: ${assignedSeats}\n📌 Next Party in Line: ${nextInLine}`;
    
    // Update the results display
    document.getElementById('results').textContent = output;
    
    // Draw seat grids
    drawSeatGrid(seatAssignments, assignedSeats, 'seatCanvas', true);
    drawSortedSeatGrid(seatAssignments, councilSeats, 'seatCanvasSorted', true);
}

// --- Seat grid functions ---
function drawSeatGrid(seats,totalSeats,canvasId, showLegend=false){
  const canvas=document.getElementById(canvasId); const ctx=canvas.getContext('2d');
  const seatSize=60; const padding=10; const seatsPerRow=Math.min(10,totalSeats); const rows=Math.ceil(totalSeats/seatsPerRow);
  canvas.width=seatsPerRow*(seatSize+padding)+padding; canvas.height=rows*(seatSize+padding)+150; ctx.clearRect(0,0,canvas.width,canvas.height);

  function wrapTextFit(context,text,x,y,maxWidth,maxHeight){
    let words=text.split(' '); let lines=[], line=''; for(let n=0;n<words.length;n++){const testLine=line+words[n]+' '; if(context.measureText(testLine).width>maxWidth && n>0){lines.push(line.trim()); line=words[n]+' ';} else line=testLine;} lines.push(line.trim());
    let fontSize=10; let lineHeight=fontSize*1.2; while(lineHeight*lines.length>maxHeight && fontSize>6){fontSize--; lineHeight=fontSize*1.2;}
    context.font=fontSize+'px Arial'; let startY=y-(lineHeight*(lines.length-1))/2; lines.forEach((l,i)=>context.fillText(l,x,startY+i*lineHeight));
  }

  seats.forEach((seat,i)=>{
    const row=Math.floor(i/seatsPerRow); const col=i%seatsPerRow;
    const x=padding+col*(seatSize+padding); const y=padding+row*(seatSize+padding);
    const partyColor=partyColorsGlobal[seat[1]]||'#888888'; const isVacant=seat[2]==='VACANT';
    ctx.fillStyle=isVacant?'#d3d3d3':partyColor; ctx.fillRect(x,y,seatSize,seatSize);
    ctx.strokeStyle=isVacant?partyColor:'#333'; ctx.lineWidth=2; ctx.strokeRect(x,y,seatSize,seatSize);
    ctx.fillStyle='#000'; ctx.textAlign='center'; ctx.font='10px Arial'; ctx.textBaseline='top'; ctx.fillText('#'+seat[0],x+seatSize/2,y+2);
    ctx.textBaseline='middle'; wrapTextFit(ctx,isVacant?`${seat[1]} VACANT`:seat[2],x+seatSize/2,y+seatSize/2,seatSize-4,seatSize-18);
  });

  if(showLegend){
    let startX=padding; let startY=rows*(seatSize+padding)+20; ctx.textAlign='left'; ctx.font='12px Arial'; ctx.textBaseline='top';
    councilPartiesGlobal.forEach(p=>{
      ctx.fillStyle=partyColorsGlobal[p]; ctx.fillRect(startX,startY,15,15);
      ctx.fillStyle='white'; // legend text white
      ctx.fillText(`${p}: ${occupiedByPartyGlobal[p]} occupied, ${vacantByPartyGlobal[p]} vacant`,startX+20,startY);
      startY+=20;
    });
    ctx.fillStyle='white'; ctx.fillText(`Next Party in Line: ${nextPartyGlobal}`,startX,startY+5);
  }
}

// --- Sorted seat grid fix: tie-break by party name ---
function drawSortedSeatGrid(seats,councilSeats,canvasId,showLegend=false){
  const canvas=document.getElementById(canvasId); const ctx=canvas.getContext('2d');
  const seatSize=60; const padding=10; const totalSeats=seats.length; const seatsPerRow=Math.min(10,totalSeats); const rows=Math.ceil(totalSeats/seatsPerRow);
  canvas.width=seatsPerRow*(seatSize+padding)+padding; canvas.height=rows*(seatSize+padding)+150; ctx.clearRect(0,0,canvas.width,canvas.height);

  const occupiedSeats=seats.filter(s=>s[2]!=='VACANT'); const vacantSeats=seats.filter(s=>s[2]==='VACANT');
  const partyCounts={}; councilPartiesGlobal.forEach(p=>partyCounts[p]=councilSeats[p]||0);

  occupiedSeats.sort((a,b)=>{
    const diff = partyCounts[b[1]] - partyCounts[a[1]];
    if(diff !==0) return diff;
    return a[1].localeCompare(b[1]); // tie-break alphabetically
  });

  const sortedSeats=[...occupiedSeats,...vacantSeats];

  function wrapTextFit(context,text,x,y,maxWidth,maxHeight){
    let words=text.split(' '); let lines=[], line=''; for(let n=0;n<words.length;n++){const testLine=line+words[n]+' '; if(context.measureText(testLine).width>maxWidth && n>0){lines.push(line.trim()); line=words[n]+' ';} else line=testLine;} lines.push(line.trim());
    let fontSize=10; let lineHeight=fontSize*1.2; while(lineHeight*lines.length>maxHeight && fontSize>6){fontSize--; lineHeight=fontSize*1.2;}
    context.font=fontSize+'px Arial'; let startY=y-(lineHeight*(lines.length-1))/2; lines.forEach((l,i)=>context.fillText(l,x,startY+i*lineHeight));
  }

  sortedSeats.forEach((seat,i)=>{
    const row=Math.floor(i/seatsPerRow); const col=i%seatsPerRow;
    const x=padding+col*(seatSize+padding); const y=padding+row*(seatSize+padding);
    const partyColor=partyColorsGlobal[seat[1]]||'#888888'; const isVacant=seat[2]==='VACANT';
    ctx.fillStyle=isVacant?'#d3d3d3':partyColor; ctx.fillRect(x,y,seatSize,seatSize);
    ctx.strokeStyle=isVacant?partyColor:'#333'; ctx.lineWidth=2; ctx.strokeRect(x,y,seatSize,seatSize);
    ctx.fillStyle='#000'; ctx.textAlign='center'; ctx.font='10px Arial'; ctx.textBaseline='top'; ctx.fillText('#'+seat[0],x+seatSize/2,y+2);
    ctx.textBaseline='middle'; wrapTextFit(ctx,isVacant?`${seat[1]} VACANT`:seat[2],x+seatSize/2,y+seatSize/2,seatSize-4,seatSize-18);
  });

  if(showLegend){
    let startX=padding; let startY=rows*(seatSize+padding)+20; ctx.textAlign='left'; ctx.font='12px Arial'; ctx.textBaseline='top';
    councilPartiesGlobal.forEach(p=>{
      ctx.fillStyle=partyColorsGlobal[p]; ctx.fillRect(startX,startY,15,15);
      ctx.fillStyle='white';
      ctx.fillText(`${p}: ${occupiedByPartyGlobal[p]} occupied, ${vacantByPartyGlobal[p]} vacant`,startX+20,startY);
      startY+=20;
    });
    ctx.fillStyle='white'; ctx.fillText(`Next Party in Line: ${nextPartyGlobal}`,startX,startY+5);
  }
}

// --- Download & export ---
function downloadSeatImage(){const canvas=document.getElementById('seatCanvas'); const link=document.createElement('a'); link.href=canvas.toDataURL('image/png'); link.download='seat_grid.png'; link.click();}
function downloadSortedSeatImage(){const canvas=document.getElementById('seatCanvasSorted'); const link=document.createElement('a'); link.href=canvas.toDataURL('image/png'); link.download='sorted_seat_grid.png'; link.click();}
function exportCSV(){const text=document.getElementById('results').textContent.replace(/\n/g,'\r\n'); const blob=new Blob([text],{type:'text/plain;charset=utf-8'}); const url=URL.createObjectURL(blob); const a=document.createElement('a'); a.href=url; a.download='allocation_results.txt'; a.click();}
</script>

</body>
</html>
